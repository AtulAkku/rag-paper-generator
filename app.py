import os
import streamlit as st
from llama_index.core import Settings
from llama_index.core import VectorStoreIndex, StorageContext
from llama_index.vector_stores.milvus import MilvusVectorStore
from llama_index.embeddings.nvidia import NVIDIAEmbedding
from llama_index.llms.nvidia import NVIDIA
from llama_index.core.node_parser import SentenceSplitter
from document_processors import load_multimodal_data, load_data_from_directory
from utils import set_environment_variables
from io import BytesIO  # Importing for file download
from pylatex import Document, Section, Command, NewPage, Package
from pylatex.utils import NoEscape
import os

# Set up the page configuration
st.set_page_config(layout="wide")

# Initialize settings
def initialize_settings():
    Settings.embed_model = NVIDIAEmbedding(model="nvidia/nv-embedqa-e5-v5", truncate="END")
    Settings.llm = NVIDIA(model="meta/llama-3.1-70b-instruct")
    Settings.text_splitter = SentenceSplitter(chunk_size=800)

# Create index from documents
def create_index(documents):
    vector_store = MilvusVectorStore(
        host="127.0.0.1",
        port=19530,
        dim=1024,
        collection_name="milvus_llamaindex",  # Set your actual collection name
        gpu_id=0  # Specify the GPU ID to use for acceleration
    )
    storage_context = StorageContext.from_defaults(vector_store=vector_store)
    return VectorStoreIndex.from_documents(documents, storage_context=storage_context)

# Generate review paper from query results using LLM model

def generate_review_paper_from_query(query, query_engine, output_filename='review_paper.pdf'):
    # Create a new LaTeX document with A4 paper and two-column layout
    doc = Document(documentclass='article', document_options='a4paper,twocolumn')

    # Add IEEE-like formatting
    doc.packages.append(Package('geometry'))
    doc.preamble.append(NoEscape(r'\geometry{top=19mm, bottom=43mm, left=14.32mm, right=14.32mm, columnsep=4.22mm}'))

    # Use Times New Roman font
    doc.packages.append(Package('times'))
    
    # Set section and subsection styles for IEEE formatting
    doc.preamble.append(NoEscape(r'\usepackage{titlesec}'))
    doc.preamble.append(NoEscape(r'\titleformat{\section}{\normalfont\fontsize{10}{12}\scshape\centring}{\thesection}{1em}{\MakeUpperCase}'))
    doc.preamble.append(NoEscape(r'\titleformat{\subsection}{\normalfont\fontsize{10}{12}\itshape}{\thesubsection}{1em}{}'))
    doc.preamble.append(NoEscape(r'\titleformat{\subsubsection}{\normalfont\fontsize{10}{12}\itshape}{\thesubsubsection}{1em}{\ignorespaces}'))

    # Use Roman numerals for section numbering, letters for subsections, and numbers for subsubsections
    doc.preamble.append(NoEscape(r'\renewcommand{\thesection}{\Roman{section}}'))
    doc.preamble.append(NoEscape(r'\renewcommand{\thesubsection}{\Alph{subsection}.}'))
    doc.preamble.append(NoEscape(r'\renewcommand{\thesubsubsection}{\arabic{subsubsection})}'))

    # No page numbers
    doc.preamble.append(NoEscape(r'\pagestyle{empty}'))

    # Title, author, and date setup
    doc.preamble.append(Command('title', 'Review Paper'))
    doc.preamble.append(Command('author', 'Generated by LLM'))
    doc.preamble.append(Command('date', NoEscape(r'\today')))
    doc.append(NoEscape(r'\maketitle'))

    # Define section prompts ensuring they don't overlap
    sections = {
        "abstract": "Summarize the key points related to the research topic, including objectives, methodology, and findings. Ensure the abstract is concise and distinct from other sections.",
        "keywords": "a short section containing keywords used in the review paper",
        "introduction": "Provide an introduction outlining the background, significance, and objectives of the research. Avoid repeating information from the abstract or other sections.",
        "literature review": (
            "Provide a comprehensive and detailed literature review on the topic, including proper citations. For each cited work, give the full reference followed by a brief summary of the research, key findings, and how it relates to the current study. Ensure that each review is distinct and includes the publication details in a citation style similar to: "
            "[56] Author(s). Title of the paper. Conference/Journal, Year. Page numbers."
            "Include insights into how this study fills the gaps identified in the existing literature."
        ),
        "results": "Describe the research findings with clear, factual detail. Avoid referencing prior sections and focus only on the results of the study.",
        "conclusion": "Summarize the key findings and discuss broader implications. Ensure the conclusions do not repeat earlier sections and offer fresh insights.",
        "Images":"In the current section please tell how many images you were given from the uploaded document and explain them as image1:discription"
    }

    # Loop through each section to generate and add content
    for section, prompt_template in sections.items():
        prompt = (
            f"{query}. {prompt_template} "
            "Please write this section in a professional, academic tone. Ensure the content is unique, and avoid using sentences or phrases from other sections. "
            "Do not include the section title in the response. Each section should be clearly distinguished with new information and original insights."
        )

        # Fetch response for the current section
        response = query_engine.query(prompt)

        # Stream the response and accumulate the full content for the section
        full_summary = ""
        for token in response.response_gen:
            full_summary += token
        
        # Add a section and content to the LaTeX document
        with doc.create(Section(section.capitalize(), numbering=False)):
            doc.append(NoEscape(full_summary))

    # If section is "abstract", make the section title bold
    if section == "abstract":
        doc.append(NoEscape(r'\textbf{Abstract-}'))  # Bold title for Abstract
        doc.append(NoEscape(r'\textit{'))  # Start italic for content
        doc.append(NoEscape(r'\textbf{'))  # Start bold for content
        doc.append(NoEscape(full_summary))  # Append abstract content
        doc.append(NoEscape(r'}'))  # End bold for content
    if section == "keyword":
        doc.append(NoEscape(r'\textbf{Keywords-}'))
        doc.append(NoEscape(r'\textit{'))
        doc.append(NoEscape(r'\textbf{'))
        doc.append(NoEscape(full_summary))
        doc.append(NoEscape(r'}')) 
    else:
        # Add a normal section for other parts of the document
        with doc.create(Section(section.capitalize(), numbering=True)):
            doc.append(NoEscape(full_summary))



    # Generate a LaTeX file
    tex_filename = 'review_paper'
    doc.generate_tex(tex_filename)

    # Compile LaTeX to PDF
    os.system(f"pdflatex {tex_filename}")

    # Clean up auxiliary files generated by pdflatex
    # for ext in ['aux', 'log', 'out', 'tex']:
    #     if os.path.exists(f"review_paper.{ext}"):
    #         os.remove(f"review_paper.{ext}")

    print(f"PDF successfully generated: {output_filename}")

    return output_filename



# Main function to run the Streamlit app
def main():
    set_environment_variables()
    initialize_settings()

    documents = None  # Initialize documents

    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.title("Multimodal RAG")
        
        input_method = st.radio("Choose input method:", ("Upload Files", "Enter Directory Path"))
        
        if input_method == "Upload Files":
            uploaded_files = st.file_uploader("Drag and drop files here", accept_multiple_files=True)
            if uploaded_files and st.button("Process Files"):
                with st.spinner("Processing files..."):
                    documents = load_multimodal_data(uploaded_files)
                    st.session_state['index'] = create_index(documents)
                    st.session_state['history'] = []
                    st.session_state['documents'] = documents
                    st.success("Files processed and index created!")
        else:
            directory_path = st.text_input("Enter directory path:")
            if directory_path and st.button("Process Directory"):
                if os.path.isdir(directory_path):
                    with st.spinner("Processing directory..."):
                        documents = load_data_from_directory(directory_path)
                        st.session_state['index'] = create_index(documents)
                        st.session_state['history'] = []
                        st.session_state['documents'] = documents
                        st.success("Directory processed and index created!")
                else:
                    st.error("Invalid directory path. Please enter a valid path.")
    
    with col2:
        if 'index' in st.session_state:
            st.title("Chat")
            if 'history' not in st.session_state:
                st.session_state['history'] = []

            query_engine = st.session_state['index'].as_query_engine(similarity_top_k=20, streaming=True)

            user_input = st.chat_input("Enter your query:")

            # Display chat messages
            chat_container = st.container()
            with chat_container:
                for message in st.session_state['history']:
                    with st.chat_message(message["role"]):
                        st.markdown(message["content"])

            if user_input:
                with st.chat_message("user"):
                    st.markdown(user_input)
                st.session_state['history'].append({"role": "user", "content": user_input})
                
                with st.chat_message("assistant"):
                    message_placeholder = st.empty()
                    full_response = ""
                    response = query_engine.query(user_input)
                    for token in response.response_gen:
                        full_response += token
                        message_placeholder.markdown(full_response + "â–Œ")
                    message_placeholder.markdown(full_response)
                st.session_state['history'].append({"role": "assistant", "content": full_response})

            if st.button("Clear Chat"):
                st.session_state['history'] = []
                st.rerun()

        # Input for review paper generation query
        st.title("Generate Review Paper")
        
        if 'index' in st.session_state:
            paper_query = st.text_input("Enter text prompt for generating a review paper:")
        
            if paper_query and st.button("Generate Review Paper"):
                with st.spinner("Generating review paper..."):
                    query_engine = st.session_state['index'].as_query_engine(similarity_top_k=20, streaming=True)
                    output_filename = generate_review_paper_from_query(paper_query, query_engine)
                    
                    # Read the generated PDF file into BytesIO for download
                    with open(output_filename, 'rb') as f:
                        pdf_data = f.read()
                        buffer = BytesIO(pdf_data)

                    # Provide a download button for the generated PDF
                    st.download_button(
                        label="Download Review Paper PDF",
                        data=buffer,
                        file_name="review_paper.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please process documents to create an index before generating a review paper.")

if __name__ == "__main__":
    main()
